use http_body_util::{BodyExt, Full};
use hyper::body::{Bytes, Incoming};
use jsonrpsee_types::{Request, Response};
use serde_json::Value;
use std::{
    future::Future,
    pin::Pin,
    task::{Context, Poll},
};
use tower::{Layer, Service};

use crate::error::JsonRpcError;

pub trait ClientRequest: Sized + Send + 'static {
    type Response: ClientResponse;

    fn from_json_rpc_request(
        request: Request<'static>,
    ) -> Pin<Box<dyn Future<Output = Result<Self, JsonRpcError>> + Send + 'static>>;
}

/// Implementation for hyper HTTP requests with `Full<Bytes>` body.
/// This is the common case when using hyper_util's legacy Client.
impl ClientRequest for hyper::Request<Full<Bytes>> {
    type Response = hyper::Response<Incoming>;

    fn from_json_rpc_request(
        request: Request<'static>,
    ) -> Pin<Box<dyn Future<Output = Result<Self, JsonRpcError>> + Send + 'static>> {
        Box::pin(async move {
            let body = serde_json::to_vec(&request)?;
            let http_request = hyper::Request::builder()
                .method(hyper::Method::POST)
                .header(hyper::header::CONTENT_TYPE, "application/json")
                .body(Full::new(Bytes::from(body)))
                .map_err(|e| JsonRpcError::RequestProcessing(e.to_string()))?;
            Ok(http_request)
        })
    }
}

/// Implementation for direct JSON-RPC requests.
/// This is used by WebSocket clients that work directly with JSON-RPC messages.
impl ClientRequest for Request<'static> {
    type Response = Response<'static, Value>;

    fn from_json_rpc_request(
        request: Request<'static>,
    ) -> Pin<Box<dyn Future<Output = Result<Self, JsonRpcError>> + Send + 'static>> {
        Box::pin(async move { Ok(request) })
    }
}

pub trait ClientResponse: Send + 'static {
    fn to_json_rpc_response(
        self,
    ) -> Pin<
        Box<dyn Future<Output = Result<Response<'static, Value>, JsonRpcError>> + Send + 'static>,
    >;
}

impl ClientResponse for hyper::Response<Incoming> {
    fn to_json_rpc_response(
        self,
    ) -> Pin<
        Box<dyn Future<Output = Result<Response<'static, Value>, JsonRpcError>> + Send + 'static>,
    > {
        Box::pin(async move {
            let body = self.into_body().collect().await.map_err(|e| {
                JsonRpcError::RequestProcessing(format!("Failed to read response body: {}", e))
            })?;
            let bytes = body.to_bytes();
            let response: Response<'_, Value> = serde_json::from_slice(&bytes)?;
            Ok(response.into_owned())
        })
    }
}

/// Implementation for direct JSON-RPC responses.
/// This is used by WebSocket clients that work directly with JSON-RPC messages.
impl ClientResponse for Response<'static, Value> {
    fn to_json_rpc_response(
        self,
    ) -> Pin<
        Box<dyn Future<Output = Result<Response<'static, Value>, JsonRpcError>> + Send + 'static>,
    > {
        Box::pin(async move { Ok(self) })
    }
}

/// Trait for RPC request enums generated by the `#[rpc(client)]` macro.
///
/// This trait is similar to `ServerRequest` but for client-side request enums.
/// Each request enum variant knows its corresponding response type.
pub trait RpcRequest: Into<Request<'static>> + Clone + Send + 'static {
    type Response: RpcResponse;

    /// Converts a successful JSON-RPC response value to the typed response.
    /// This is called after the RPC call completes successfully.
    fn parse_response(&self, value: Value) -> Result<Self::Response, JsonRpcError>;
}

/// Trait for RPC response enums generated by the `#[rpc(client)]` macro.
///
/// This trait is similar to `ServerResponse` but for client-side response enums.
pub trait RpcResponse: Sized + Send + 'static {}

/// A subscription ID returned by the server when subscribing.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SubscriptionId(pub String);

impl From<String> for SubscriptionId {
    fn from(s: String) -> Self {
        SubscriptionId(s)
    }
}

impl From<u64> for SubscriptionId {
    fn from(n: u64) -> Self {
        SubscriptionId(n.to_string())
    }
}

/// An active subscription that yields items of type `T`.
///
/// This is returned by subscription methods and implements `Stream<Item = Result<T, JsonRpcError>>`.
pub struct Subscription<T> {
    /// The subscription ID assigned by the server
    pub id: SubscriptionId,
    /// Receiver for subscription notifications
    rx: futures::channel::mpsc::UnboundedReceiver<Result<T, JsonRpcError>>,
}

impl<T> Subscription<T> {
    /// Create a new subscription with the given ID and receiver.
    pub fn new(
        id: SubscriptionId,
        rx: futures::channel::mpsc::UnboundedReceiver<Result<T, JsonRpcError>>,
    ) -> Self {
        Self { id, rx }
    }

    /// Get the subscription ID.
    pub fn subscription_id(&self) -> &SubscriptionId {
        &self.id
    }
}

impl<T> futures::Stream for Subscription<T> {
    type Item = Result<T, JsonRpcError>;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        Pin::new(&mut self.rx).poll_next(cx)
    }
}

/// Trait for subscription transports that can manage active subscriptions.
///
/// This trait must be implemented by transport types that support subscriptions
/// (e.g., WebSocket clients). HTTP clients cannot support subscriptions.
pub trait SubscriptionTransport: Send + 'static {
    /// Subscribe to notifications and return a channel receiver for items.
    fn subscribe<T: serde::de::DeserializeOwned + Send + 'static>(
        &self,
        subscribe_method: &str,
        params: Option<Box<serde_json::value::RawValue>>,
        unsubscribe_method: String,
    ) -> Pin<Box<dyn Future<Output = Result<Subscription<T>, JsonRpcError>> + Send + 'static>>;
}

/// Trait for making RPC calls using a request enum.
///
/// This trait is automatically implemented for any service that implements
/// `Service<TransportReq>` where `TransportReq: ClientRequest`. The request
/// enum type must implement `RpcRequest`.
///
/// # Example
///
/// ```ignore
/// use tower_json_rpc::client::RpcCall;
///
/// // SayRequest and SayResponse are generated by the #[rpc(client)] macro
/// let response: SayResponse = client.rpc_call(SayRequest::Hello { name: "world".into() }).await?;
/// ```
pub trait RpcCall<Req, TransportReq>
where
    Req: RpcRequest,
    TransportReq: ClientRequest,
{
    fn rpc_call(
        &self,
        request: Req,
    ) -> Pin<Box<dyn Future<Output = Result<Req::Response, JsonRpcError>> + 'static>>;
}

impl<T, Req, TransportReq> RpcCall<Req, TransportReq> for T
where
    Req: RpcRequest,
    TransportReq: ClientRequest + Send + 'static,
    TransportReq::Response: ClientResponse + Send + 'static,
    T: Service<TransportReq, Response = <TransportReq as ClientRequest>::Response>
        + Clone
        + Send
        + 'static,
    <T as Service<TransportReq>>::Future: 'static,
    <T as Service<TransportReq>>::Error: Into<JsonRpcError> + Send + 'static,
{
    fn rpc_call(
        &self,
        request: Req,
    ) -> Pin<Box<dyn Future<Output = Result<Req::Response, JsonRpcError>> + 'static>> {
        let json_request: Request<'static> = request.clone().into();
        let service = self.clone();
        Box::pin(async move {
            let client_request = TransportReq::from_json_rpc_request(json_request).await?;
            let mut service = service;
            crate::__private::futures_util::future::poll_fn(|cx| {
                match Service::poll_ready(&mut service, cx) {
                    Poll::Ready(Ok(())) => Poll::Ready(Ok(())),
                    Poll::Ready(Err(err)) => Poll::Ready(Err(err.into())),
                    Poll::Pending => Poll::Pending,
                }
            })
            .await?;
            let response = Service::call(&mut service, client_request)
                .await
                .map_err(Into::into)?;
            let response =
                <TransportReq::Response as ClientResponse>::to_json_rpc_response(response).await?;
            match response.payload {
                jsonrpsee_types::ResponsePayload::Success(value) => {
                    request.parse_response(value.into_owned())
                }
                jsonrpsee_types::ResponsePayload::Error(err) => {
                    Err(JsonRpcError::RequestProcessing(err.to_string()))
                }
            }
        })
    }
}

/// A layer that maps http requests to JSON-RPC requests.
#[derive(Clone, Debug)]
pub struct JsonRpcClientLayer<Req> {
    _req: std::marker::PhantomData<Req>,
}

impl<Req> Default for JsonRpcClientLayer<Req> {
    fn default() -> Self {
        Self {
            _req: std::marker::PhantomData,
        }
    }
}

impl<S, Req> Layer<S> for JsonRpcClientLayer<Req> {
    type Service = JsonRpcClient<S, Req>;

    fn layer(&self, inner: S) -> Self::Service {
        JsonRpcClient {
            inner,
            _req: std::marker::PhantomData,
        }
    }
}

/// Maps JSON-RPC requests to client requests
#[derive(Debug, Clone)]
pub struct JsonRpcClient<S, Req> {
    inner: S,
    _req: std::marker::PhantomData<Req>,
}

impl<S, Req> Service<Request<'static>> for JsonRpcClient<S, Req>
where
    Req: ClientRequest + Send + 'static,
    S: Service<Req, Response = <Req as ClientRequest>::Response> + Clone + Send + 'static,
    S::Future: Send + 'static,
    S::Error: Into<JsonRpcError> + Send + 'static,
{
    type Response = Response<'static, Value>;
    type Error = JsonRpcError;
    type Future =
        Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send + 'static>>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        self.inner.poll_ready(cx).map_err(Into::into)
    }

    fn call(&mut self, request: Request<'static>) -> Self::Future {
        let mut service = self.inner.clone();

        Box::pin(async move {
            let client_request = Req::from_json_rpc_request(request).await?;
            let response = service.call(client_request).await.map_err(Into::into)?;
            response.to_json_rpc_response().await
        })
    }
}
#[cfg(test)]
mod tests {
    use jsonrpsee_types::{Id, Request, Response, ResponsePayload};
    use std::{future::Future, pin::Pin};
    use tower::{ServiceBuilder, ServiceExt, service_fn};

    use crate::client::{ClientRequest, ClientResponse, JsonRpcClientLayer};
    use crate::error::JsonRpcError;

    #[derive(Clone)]
    struct DummyRequest(Request<'static>);

    struct DummyResponse(Response<'static, serde_json::Value>);

    impl ClientRequest for DummyRequest {
        type Response = DummyResponse;

        fn from_json_rpc_request(
            request: Request<'static>,
        ) -> Pin<Box<dyn Future<Output = Result<Self, JsonRpcError>> + Send + 'static>> {
            Box::pin(async move { Ok(DummyRequest(request)) })
        }
    }

    impl ClientResponse for DummyResponse {
        fn to_json_rpc_response(
            self,
        ) -> Pin<
            Box<
                dyn Future<Output = Result<Response<'static, serde_json::Value>, JsonRpcError>>
                    + Send
                    + 'static,
            >,
        > {
            Box::pin(async move { Ok(self.0) })
        }
    }

    #[tokio::test]
    async fn client_layer_roundtrip() {
        let service = ServiceBuilder::new()
            .layer(JsonRpcClientLayer::<DummyRequest>::default())
            .service(service_fn(|req: DummyRequest| async move {
                let id = req.0.id.clone();
                let method = req.0.method.to_string();
                Ok::<_, std::convert::Infallible>(DummyResponse(Response::new(
                    ResponsePayload::success(serde_json::json!({ "method": method })),
                    id,
                )))
            }));

        let request: Request<'static> = Request::owned("ping".to_string(), None, Id::Number(7));

        let response = service.oneshot(request).await.unwrap();
        assert!(matches!(response.payload, ResponsePayload::Success(_)));
    }
}
