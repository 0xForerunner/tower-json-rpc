#![allow(async_fn_in_trait)]

use http_body_util::Full;
use hyper::body::Bytes;
use hyper_util::client::legacy::Client;
use hyper_util::rt::TokioExecutor;
use tower_json_rpc::client::RpcCall;
use tower_json_rpc::error::JsonRpcError;
use tower_json_rpc::types::Request;
use tower_json_rpc_derive::rpc;

#[rpc(client, namespace = "say")]
pub trait Say {
    async fn hello(&self, name: String) -> Result<String, JsonRpcError>;
}

#[tokio::main]
async fn main() -> Result<(), JsonRpcError> {
    let client: Client<_, Full<Bytes>> = Client::builder(TokioExecutor::new()).build_http();

    // The SayClient trait is automatically generated by the #[rpc(client)] macro.
    // It extends any Service<Request<Full<Bytes>>> with RPC methods.
    let result = client.hello("test".into()).await?;
    println!("Result from say_hello: {}", result);

    // You can also use rpc_call with the generated SayRequest enum.
    // This returns the typed SayResponse enum.
    let response: SayResponse = client
        .rpc_call(SayRequest::Hello {
            name: "test".into(),
        })
        .await?;

    // Extract the value from the response variant
    match response {
        SayResponse::Hello(message) => println!("Result from rpc_call: {}", message),
    }

    let req = Request::owned(
        "say_hello".to_string(),
        Some(serde_json::value::to_raw_value(&vec!["test"]).unwrap()),
        jsonrpsee_types::Id::Number(1),
    );
    client.rpc_call(req).await?;

    Ok(())
}
